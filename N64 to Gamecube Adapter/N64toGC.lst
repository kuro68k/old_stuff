
AVRASM ver. 2.1.17  E:\code\AVR\N64 to Gamecube Adapter\N64toGC.asm Thu Jul 16 19:42:29 2009

E:\code\AVR\N64 to Gamecube Adapter\N64toGC.asm(1): Including file 'd:\AVR Tools\AvrAssembler2\Appnotes\tn461def.inc'
                 
                 
                 
                 ;***** Created: 2008-04-10 09:30 ******* Source: ATtiny461.xml ***********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn461def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny461
                 ;* Date              : 2008-04-10
                 ;* Version           : 2.25
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny461
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN461DEF_INC_
                 #define _TN461DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATtiny461
                 #pragma AVRPART ADMIN PART_NAME ATtiny461
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x92
                 .equ	SIGNATURE_002	= 0x08
                 
                 #pragma AVRPART CORE CORE_VERSION V2
                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GIMSK	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCSR	= 0x37
                 .equ	PRR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	TCCR0B	= 0x33
                 .equ	TCNT0L	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	TCCR1A	= 0x30
                 .equ	TCCR1B	= 0x2f
                 .equ	TCNT1	= 0x2e
                 .equ	OCR1A	= 0x2d
                 .equ	OCR1B	= 0x2c
                 .equ	OCR1C	= 0x2b
                 .equ	OCR1D	= 0x2a
                 .equ	PLLCSR	= 0x29
                 .equ	CLKPR	= 0x28
                 .equ	TCCR1C	= 0x27
                 .equ	TCCR1D	= 0x26
                 .equ	TC1H	= 0x25
                 .equ	DT1	= 0x24
                 .equ	PCMSK0	= 0x23
                 .equ	PCMSK1	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	DWDR	= 0x20
                 .equ	EEARH	= 0x1f
                 .equ	EEARL	= 0x1e
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTA	= 0x1b
                 .equ	DDRA	= 0x1a
                 .equ	PINA	= 0x19
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	TCCR0A	= 0x15
                 .equ	TCNT0H	= 0x14
                 .equ	OCR0A	= 0x13
                 .equ	OCR0B	= 0x12
                 .equ	USIPP	= 0x11
                 .equ	USIBR	= 0x10
                 .equ	USIDR	= 0x0f
                 .equ	USISR	= 0x0e
                 .equ	USICR	= 0x0d
                 .equ	GPIOR2	= 0x0c
                 .equ	GPIOR1	= 0x0b
                 .equ	GPIOR0	= 0x0a
                 .equ	ACSRB	= 0x09
                 .equ	ACSRA	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	ADCSRB	= 0x03
                 .equ	DIDR1	= 0x02
                 .equ	DIDR0	= 0x01
                 .equ	TCCR1E	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADPS0	= 0	; ADC Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                 .equ	MUX5	= 3	; 
                 .equ	REFS2	= 4	; 
                 .equ	IPR	= 5	; Input Polarity Mode
                 .equ	GSEL	= 6	; Gain Select
                 .equ	BIN	= 7	; Bipolar Input Mode
                 
                 ; DIDR0 - Digital Input Disable Register 0
                 .equ	ADC0D	= 0	; ADC0 Digital input Disable
                 .equ	ADC1D	= 1	; ADC1 Digital input Disable
                 .equ	ADC2D	= 2	; ADC2 Digital input Disable
                 .equ	AREFD	= 3	; AREF Digital Input Disable
                 .equ	ADC3D	= 4	; ADC3 Digital input Disable
                 .equ	ADC4D	= 5	; ADC4 Digital input Disable
                 .equ	ADC5D	= 6	; ADC5 Digital input Disable
                 .equ	ADC6D	= 7	; ADC6 Digital input Disable
                 
                 ; DIDR1 - Digital Input Disable Register 1
                 .equ	ADC7D	= 4	; ADC7 Digital input Disable
                 .equ	ADC8D	= 5	; ADC8 Digital input Disable
                 .equ	ADC9D	= 6	; ADC9 Digital input Disable
                 .equ	ADC10D	= 7	; ADC10 Digital input Disable
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ACSRA - Analog Comparator Control And Status Register A
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACME	= 2	; Analog Comparator Multiplexer Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; ACSRB - Analog Comparator Control And Status Register B
                 .equ	ACM0	= 0	; Analog Comparator Multiplexer
                 .equ	ACM1	= 1	; Analog Comparator Multiplexer
                 .equ	ACM2	= 2	; Analog Comparator Multiplexer
                 .equ	HLEV	= 6	; Hysteresis Level
                 .equ	HSEL	= 7	; Hysteresis Select
                 
                 
                 ; ***** USI **************************
                 ; USIPP - USI Pin Position
                 .equ	USIPOS	= 0	; USI Pin Position
                 
                 ; USIBR - USI Buffer Register
                 .equ	USIBR0	= 0	; USI Buffer Register bit 0
                 .equ	USIBR1	= 1	; USI Buffer Register bit 1
                 .equ	USIBR2	= 2	; USI Buffer Register bit 2
                 .equ	USIBR3	= 3	; USI Buffer Register bit 3
                 .equ	USIBR4	= 4	; USI Buffer Register bit 4
                 .equ	USIBR5	= 5	; USI Buffer Register bit 5
                 .equ	USIBR6	= 6	; USI Buffer Register bit 6
                 .equ	USIBR7	= 7	; USI Buffer Register bit 7
                 
                 ; USIDR - USI Data Register
                 .equ	USIDR0	= 0	; USI Data Register bit 0
                 .equ	USIDR1	= 1	; USI Data Register bit 1
                 .equ	USIDR2	= 2	; USI Data Register bit 2
                 .equ	USIDR3	= 3	; USI Data Register bit 3
                 .equ	USIDR4	= 4	; USI Data Register bit 4
                 .equ	USIDR5	= 5	; USI Data Register bit 5
                 .equ	USIDR6	= 6	; USI Data Register bit 6
                 .equ	USIDR7	= 7	; USI Data Register bit 7
                 
                 ; USISR - USI Status Register
                 .equ	USICNT0	= 0	; USI Counter Value Bit 0
                 .equ	USICNT1	= 1	; USI Counter Value Bit 1
                 .equ	USICNT2	= 2	; USI Counter Value Bit 2
                 .equ	USICNT3	= 3	; USI Counter Value Bit 3
                 .equ	USIDC	= 4	; Data Output Collision
                 .equ	USIPF	= 5	; Stop Condition Flag
                 .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                 .equ	USISIF	= 7	; Start Condition Interrupt Flag
                 
                 ; USICR - USI Control Register
                 .equ	USITC	= 0	; Toggle Clock Port Pin
                 .equ	USICLK	= 1	; Clock Strobe
                 .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                 .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                 .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                 .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                 .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                 .equ	USISIE	= 7	; Start Condition Interrupt Enable
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TICIE0	= 0	; Timer/Counter0 Input Capture Interrupt Enable
                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 .equ	OCIE0A	= 4	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 
                 ; TIFR - Timer/Counter0 Interrupt Flag register
                 .equ	ICF0	= 0	; Timer/Counter0 Input Capture Flag
                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                 .equ	OCF0A	= 4	; Timer/Counter0 Output Compare Flag 0A
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	ACIC0	= 3	; Analog Comparator Input Capture Enable
                 .equ	ICES0	= 4	; Input Capture Edge Select
                 .equ	ICNC0	= 5	; Input Capture Noice Canceler
                 .equ	ICEN0	= 6	; Input Capture Mode Enable
                 .equ	TCW0	= 7	; Timer/Counter 0 Width
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	PSR0	= 3	; Timer/Counter 0 Prescaler Reset
                 .equ	TSM	= 4	; Timer/Counter Synchronization Mode
                 
                 ; TCNT0H - Timer/Counter0 High
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; TCNT0L - Timer/Counter0 Low
                 ;.equ	TCNT0_0	= 0	; 
                 ;.equ	TCNT0_1	= 1	; 
                 ;.equ	TCNT0_2	= 2	; 
                 ;.equ	TCNT0_3	= 3	; 
                 ;.equ	TCNT0_4	= 4	; 
                 ;.equ	TCNT0_5	= 5	; 
                 ;.equ	TCNT0_6	= 6	; 
                 ;.equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 ;.equ	OCR0_0	= 0	; 
                 ;.equ	OCR0_1	= 1	; 
                 ;.equ	OCR0_2	= 2	; 
                 ;.equ	OCR0_3	= 3	; 
                 ;.equ	OCR0_4	= 4	; 
                 ;.equ	OCR0_5	= 5	; 
                 ;.equ	OCR0_6	= 6	; 
                 ;.equ	OCR0_7	= 7	; 
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TCCR1A - Timer/Counter Control Register A
                 .equ	PWM1B	= 0	; Pulse Width Modulator Enable
                 .equ	PWM1A	= 1	; Pulse Width Modulator Enable
                 .equ	FOC1B	= 2	; Force Output Compare Match 1B
                 .equ	FOC1A	= 3	; Force Output Compare Match 1A
                 .equ	COM1B0	= 4	; Compare Output Mode, Bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode, Bit 1
                 .equ	COM1A0	= 6	; Compare Output Mode, Bit 1
                 .equ	COM1A1	= 7	; Compare Output Mode, Bit 0
                 
                 ; TCCR1B - Timer/Counter Control Register B
                 .equ	CS10	= 0	; Clock Select Bits
                 .equ	CS11	= 1	; Clock Select Bits
                 .equ	CS12	= 2	; Clock Select Bits
                 .equ	CS13	= 3	; Clock Select Bits
                 .equ	DTPS10	= 4	; Dead Time Prescaler
                 .equ	DTPS11	= 5	; Dead Time Prescaler
                 .equ	PSR1	= 6	; Timer/Counter 1 Prescaler reset
                 
                 ; TCCR1C - Timer/Counter Control Register C
                 .equ	PWM1D	= 0	; Pulse Width Modulator D Enable
                 .equ	FOC1D	= 1	; Force Output Compare Match 1D
                 .equ	COM1D0	= 2	; Comparator D output mode
                 .equ	COM1D1	= 3	; Comparator D output mode
                 .equ	COM1B0S	= 4	; COM1B0 Shadow Bit
                 .equ	COM1B1S	= 5	; COM1B1 Shadow Bit
                 .equ	COM1A0S	= 6	; COM1A0 Shadow Bit
                 .equ	COM1A1S	= 7	; COM1A1 Shadow Bit
                 
                 ; TCCR1D - Timer/Counter Control Register D
                 .equ	WGM10	= 0	; Waveform Generation Mode Bit
                 .equ	WGM11	= 1	; Waveform Generation Mode Bit
                 .equ	FPF1	= 2	; Fault Protection Interrupt Flag
                 .equ	FPAC1	= 3	; Fault Protection Analog Comparator Enable
                 .equ	FPES1	= 4	; Fault Protection Edge Select
                 .equ	FPNC1	= 5	; Fault Protection Noise Canceler
                 .equ	FPEN1	= 6	; Fault Protection Mode Enable
                 .equ	FPIE1	= 7	; Fault Protection Interrupt Enable
                 
                 ; TCCR1E - Timer/Counter1 Control Register E
                 .equ	OC1OE0	= 0	; Ouput Compare Override Enable Bit 0
                 .equ	OC1OE1	= 1	; Ouput Compare Override Enable Bit 1
                 .equ	OC1OE2	= 2	; Ouput Compare Override Enable Bit 2
                 .equ	OC1OE3	= 3	; Ouput Compare Override Enable Bit 3
                 .equ	OC1OE4	= 4	; Ouput Compare Override Enable Bit 4
                 .equ	OC1OE5	= 5	; Ouput Compare Override Enable Bit 5
                 
                 ; TCNT1 - Timer/Counter Register
                 .equ	TC1H_0	= 0	; Timer/Counter Register Bit 0
                 .equ	TC1H_1	= 1	; Timer/Counter Register Bit 1
                 .equ	TC1H_2	= 2	; Timer/Counter Register Bit 2
                 .equ	TC1H_3	= 3	; Timer/Counter Register Bit 3
                 .equ	TC1H_4	= 4	; Timer/Counter Register Bit 4
                 .equ	TC1H_5	= 5	; Timer/Counter Register Bit 5
                 .equ	TC1H_6	= 6	; Timer/Counter Register Bit 6
                 .equ	TC1H_7	= 7	; Timer/Counter Register Bit 7
                 
                 ; TC1H - Timer/Counter 1 Register High
                 .equ	TC18	= 0	; Timer/Counter Register Bit 0
                 .equ	TC19	= 1	; Timer/Counter Register Bit 1
                 
                 ; OCR1A - Output Compare Register
                 .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
                 .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
                 .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
                 .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
                 .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
                 .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
                 .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
                 .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
                 
                 ; OCR1B - Output Compare Register
                 .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
                 .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
                 .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
                 .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
                 .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
                 .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
                 .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
                 .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
                 
                 ; OCR1C - Output compare register
                 .equ	OCR1C0	= 0	; 
                 .equ	OCR1C1	= 1	; 
                 .equ	OCR1C2	= 2	; 
                 .equ	OCR1C3	= 3	; 
                 .equ	OCR1C4	= 4	; 
                 .equ	OCR1C5	= 5	; 
                 .equ	OCR1C6	= 6	; 
                 .equ	OCR1C7	= 7	; 
                 
                 ; OCR1D - Output compare register
                 .equ	OCR1D0	= 0	; 
                 .equ	OCR1D1	= 1	; 
                 .equ	OCR1D2	= 2	; 
                 .equ	OCR1D3	= 3	; 
                 .equ	OCR1D4	= 4	; 
                 .equ	OCR1D5	= 5	; 
                 .equ	OCR1D6	= 6	; 
                 ;.equ	OCR1C7	= 7	; 
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 5	; OCIE1A: Timer/Counter1 Output Compare B Interrupt Enable
                 .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
                 .equ	OCIE1D	= 7	; OCIE1D: Timer/Counter1 Output Compare Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 5	; Timer/Counter1 Output Compare Flag 1B
                 .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
                 .equ	OCF1D	= 7	; Timer/Counter1 Output Compare Flag 1D
                 
                 ; DT1 - Timer/Counter 1 Dead Time Value
                 .equ	DT1L0	= 0	; 
                 .equ	DT1L1	= 1	; 
                 .equ	DT1L2	= 2	; 
                 .equ	DT1L3	= 3	; 
                 .equ	DT1H0	= 4	; 
                 .equ	DT1H1	= 5	; 
                 .equ	DT1H2	= 6	; 
                 .equ	DT1H3	= 7	; 
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	RFLB	= 3	; Read fuse and lock bits
                 .equ	CTPB	= 4	; Clear temporary page buffer
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                 .equ	SE	= 5	; Sleep Enable
                 .equ	PUD	= 6	; Pull-up Disable
                 
                 ; MCUSR - MCU Status register
                 .equ	PORF	= 0	; Power-On Reset Flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSI	= 1	; Power Reduction USI
                 .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 
                 ; OSCCAL - Oscillator Calibration Register
                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                 .equ	CAL7	= 7	; Oscillatro Calibration Value Bit 7
                 
                 ; PLLCSR - PLL Control and status register
                 .equ	PLOCK	= 0	; PLL Lock detector
                 .equ	PLLE	= 1	; PLL Enable
                 .equ	PCKE	= 2	; PCK Enable
                 .equ	LSM	= 7	; Low speed mode
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; DWDR - debugWire data register
                 .equ	DWDR0	= 0	; 
                 .equ	DWDR1	= 1	; 
                 .equ	DWDR2	= 2	; 
                 .equ	DWDR3	= 3	; 
                 .equ	DWDR4	= 4	; 
                 .equ	DWDR5	= 5	; 
                 .equ	DWDR6	= 6	; 
                 .equ	DWDR7	= 7	; 
                 
                 ; GPIOR2 - General Purpose IO register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General purpose register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 
                 ; GIMSK - General Interrupt Mask Register
                 .equ	GICR	= GIMSK	; For compatibility
                 .equ	PCIE0	= 4	; Pin Change Interrupt Enable 0
                 .equ	PCIE1	= 5	; Pin Change Interrupt Enable 1
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag register
                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; PCMSK0 - Pin Change Enable Mask 0
                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                 .equ	PCINT6	= 6	; Pin Change Enable Mask Bit 6
                 .equ	PCINT7	= 7	; Pin Change Enable Mask Bit 7
                 
                 ; PCMSK1 - Pin Change Enable Mask 1
                 .equ	PCINT8	= 0	; Pin Change Enable Mask Bit 8
                 .equ	PCINT9	= 1	; Pin Change Enable Mask Bit 9
                 .equ	PCINT10	= 2	; Pin Change Enable Mask Bit 10
                 .equ	PCINT11	= 3	; Pin Change Enable Mask Bit 11
                 .equ	PCINT12	= 4	; Pin Change Enable Mask Bit 12
                 .equ	PCINT13	= 5	; Pin Change Enable Mask Bit 13
                 .equ	PCINT14	= 6	; Pin Change Enable Mask Bit 14
                 .equ	PCINT15	= 7	; Pin Change Enable Mask Bit 15
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lockbit
                 .equ	LB2	= 1	; Lockbit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock source
                 .equ	CKSEL1	= 1	; Select Clock source
                 .equ	CKSEL2	= 2	; Select Clock source
                 .equ	CKSEL3	= 3	; Select Clock source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock Output Enable
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
                 .equ	WDTON	= 4	; Watchdog Timer always on
                 .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
                 .equ	DWEN	= 6	; DebugWIRE Enable
                 .equ	RSTDISBL	= 7	; External Reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	SELFPRGEN	= 0	; Self-Programming Enable
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x07ff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 256
                 .equ	RAMEND	= 0x015f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x00ff
                 .equ	EEPROMEND	= 0x00ff
                 .equ	EEADRBITS	= 8
                 #pragma AVRPART MEMORY PROG_FLASH 4096
                 #pragma AVRPART MEMORY EEPROM 256
                 #pragma AVRPART MEMORY INT_SRAM SIZE 256
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x0
                 .equ	NRWW_STOP_ADDR	= 0x7ff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x0
                 .equ	PAGESIZE	= 32
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                 .equ	PCIaddr	= 0x0002	; Pin Change Interrupt
                 .equ	OC1Aaddr	= 0x0003	; Timer/Counter1 Compare Match 1A
                 .equ	OC1Baddr	= 0x0004	; Timer/Counter1 Compare Match 1B
                 .equ	OVF1addr	= 0x0005	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0006	; Timer/Counter0 Overflow
                 .equ	USI_STARTaddr	= 0x0007	; USI Start
                 .equ	USI_OVFaddr	= 0x0008	; USI Overflow
                 .equ	ERDYaddr	= 0x0009	; EEPROM Ready
                 .equ	ACIaddr	= 0x000a	; Analog Comparator
                 .equ	ADCCaddr	= 0x000b	; ADC Conversion Complete
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-Out
                 .equ	INT1addr	= 0x000d	; External Interrupt 1
                 .equ	OC0Aaddr	= 0x000e	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x000f	; Timer/Counter0 Compare Match B
                 .equ	ICP0addr	= 0x0010	; ADC Conversion Complete
                 .equ	OC1Daddr	= 0x0011	; Timer/Counter1 Compare Match D
                 .equ	FAULT_PROTaddr	= 0x0012	; Timer/Counter1 Fault Protection
                 
                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                 
                 #endif  /* _TN461DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 .def	gcint	= R0	; set by interrupt, indicates N64 data comms may have been
                 						; interrupted
                 
                 .def	shift	= R4
                 
                 .def	recal	= R5
                 .def	calx	= R6	; joystick calibration
                 .def	caly	= R7
                 
                 .def	rstate	= R8	; flag - rumble currently on or off
                 .def	rwant	= R3	; flag - state GC wants rumble to be in
                 .def	fail	= R9
                 
                 .def	gc1		= R10	; Gamecube data
                 .def	gc2		= R11
                 .def	gcx		= R12
                 .def	gcy		= R13
                 .def	gcl		= R14
                 .def	gcr		= R15
                 
                 .def	temp1	= R16
                 .def	temp2	= R17
                 .def 	nsix1	= R18
                 .def 	nsix2	= R19
                 
                 .def	count	= R20
                 .def	timer	= R21
                 
                 .def	param	= R22
                 
                 .equ	MSD3	= 14	; 13
                 .equ	MSD2	= 8
                 .equ	MSD1	= 2		; 3
                 
                 ; Timing macro
                 .MACRO DELAY
                 		ldi		timer, @0
                 DELAY_LOOP:
                 		dec		timer
                 		brne	DELAY_LOOP
                 .ENDMACRO
                 
                 .LISTMAC
                 
                 ;------------------------------------------------------------------------------------------
                 ; Hardware setup
                 ;------------------------------------------------------------------------------------------
                 
                 ;	N64			- PB3
                 ;	N64 2nd Z	- PB1
                 ;	Gamecube	- PB6
                 ;	Debug		- PA0
                 
                 .equ	nsd		= 3
                 .equ	gcd		= 6
                 .equ	z2		= 1
                 
                 ;------------------------------------------------------------------------------------------
                 ; Interrupt table
                 ;------------------------------------------------------------------------------------------
                 .cseg
                 
                 .org 0							;after reset
000000 c001      		rjmp	reset
                 .org INT0addr					;external interrupt INT0
000001 c11a      		rjmp	INT0handler
                 
                 
                 ;------------------------------------------------------------------------------------------
                 ; Startup
                 ;------------------------------------------------------------------------------------------
                 reset:
000002 e001      		ldi		temp1, HIGH(RAMEND)	; Upper byte
000003 bf0e      		out 	SPH,temp1			; to stack pointer
000004 e50f      		ldi		temp1, LOW(RAMEND)	; Lower byte
000005 bf0d      		out		SPL, temp1			; to stack pointer
                 
000006 9ad9      		sbi		PORTA, 1		; debug
000007 98d9      		cbi		PORTA, 1
000008 9ad9      		sbi		PORTA, 1		; debug
000009 98d9      		cbi		PORTA, 1
00000a 9ad9      		sbi		PORTA, 1		; debug
00000b 98d9      		cbi		PORTA, 1
00000c 9ad9      		sbi		PORTA, 1		; debug
00000d 98d9      		cbi		PORTA, 1
00000e 9ad9      		sbi		PORTA, 1		; debug
00000f 98d9      		cbi		PORTA, 1
000010 9ad9      		sbi		PORTA, 1		; debug
000011 98d9      		cbi		PORTA, 1
000012 9ad9      		sbi		PORTA, 1		; debug
000013 98d9      		cbi		PORTA, 1
000014 9ad9      		sbi		PORTA, 1		; debug
000015 98d9      		cbi		PORTA, 1
000016 9ad9      		sbi		PORTA, 1		; debug
000017 98d9      		cbi		PORTA, 1
000018 9ad9      		sbi		PORTA, 1		; debug
000019 98d9      		cbi		PORTA, 1
00001a 9ad9      		sbi		PORTA, 1		; debug
00001b 98d9      		cbi		PORTA, 1
00001c 9ad9      		sbi		PORTA, 1		; debug
00001d 98d9      		cbi		PORTA, 1
00001e 9ad9      		sbi		PORTA, 1		; debug
00001f 98d9      		cbi		PORTA, 1
000020 9ad9      		sbi		PORTA, 1		; debug
000021 98d9      		cbi		PORTA, 1
000022 9ad9      		sbi		PORTA, 1		; debug
000023 98d9      		cbi		PORTA, 1
000024 9ad9      		sbi		PORTA, 1		; debug
000025 98d9      		cbi		PORTA, 1
000026 9ad9      		sbi		PORTA, 1		; debug
000027 98d9      		cbi		PORTA, 1
000028 9ad9      		sbi		PORTA, 1		; debug
000029 98d9      		cbi		PORTA, 1
                 
00002a 2466      		clr		calx
00002b 2477      		clr		caly
                 
00002c 2488      		clr		rstate
00002d 2433      		clr		rwant
00002e 2444      		clr		shift
                 
00002f 24aa      		clr		gc1
000030 24bb      		clr		gc2
000031 24cc      		clr		gcx
000032 24dd      		clr		gcy
000033 24ee      		clr		gcl
000034 24ff      		clr		gcr
                 
000035 98c3      		cbi		PORTB, nsd		; inputs, no pull-ups (use external 3.3V pull ups)
000036 98c6      		cbi		PORTB, gcd
000037 98bb      		cbi		DDRB, nsd
000038 98be      		cbi		DDRB, gcd
                 
000039 98b9      		cbi		DDRB, z2		; 2nd Z button input with pull-up
00003a 9ac1      		sbi		PORTB, z2
                 
00003b 98d8      		cbi		PORTA, 0		; N64 debug
00003c 9ad0      		sbi		DDRA, 0
00003d 98d9      		cbi		PORTA, 1		; Gamecube debug
00003e 9ad1      		sbi		DDRA, 1
00003f 98da      		cbi		PORTA, 2		; rumble debug
000040 9ad2      		sbi		DDRA, 2
                 
000041 e002      		ldi		temp1, 1<<ISC01	; trigger on falling edge
000042 bf05      		out		MCUCR, temp1
000043 e400      		ldi		temp1, 1<<INT0	; INT0 enabled
000044 bf0b      		out		GIMSK, temp1
                 
                 		;sei						; interupts enabled
                 
                 ;------------------------------------------------------------------------------------------
                 ; Main loop
                 ;
                 ; Continually read the pad
                 ;------------------------------------------------------------------------------------------
                 
                 mainloop:
000045 e020      		ldi		nsix1, 0
000046 e030      		ldi		nsix2, 0
000047 e000      		ldi		temp1, 0
000048 e010      		ldi		temp2, 0
                 
                +
000049 ef5f     +ldi timer , 255
                +DELAY_LOOP :
00004a 955a     +dec timer
00004b f7f1     +brne DELAY_LOOP
                 		DELAY	255
                +
00004c e956     +ldi timer , 150
                +DELAY_LOOP :
00004d 955a     +dec timer
00004e f7f1     +brne DELAY_LOOP
                 		DELAY	150
                 
                 		; send 0x00 to identify controller
00004f e060      		ldi		param, 0x00
000050 d0a2      		rcall	writebyte
000051 d0c3      		rcall	writestopbit
                 
                 		; read three bytes for id
000052 d086      		rcall	readbyte
000053 2f26      		mov		nsix1, param
000054 d084      		rcall	readbyte
000055 2f36      		mov		nsix2, param
000056 d082      		rcall	readbyte
000057 2f06      		mov		temp1, param
                 
                +
000058 ef5f     +ldi timer , 255
                +DELAY_LOOP :
000059 955a     +dec timer
00005a f7f1     +brne DELAY_LOOP
                 		DELAY	255
                +
00005b e956     +ldi timer , 150
                +DELAY_LOOP :
00005c 955a     +dec timer
00005d f7f1     +brne DELAY_LOOP
                 		DELAY	150
                 
00005e 3025      		cpi		nsix1, 0x05		; N64 pad
00005f f039      		breq	readn64
                 
000060 e104      		ldi		temp1, 20		; if we fail to read pad 20 times, recalibrate
000061 1650      		cp		recal, temp1
000062 f711      		brne	mainloop
                 
000063 94f8      		cli						; no N64 pad, so stop responding to GC polls
000064 2466      		clr		calx			; reset calibration data
000065 2477      		clr		caly
                 
000066 cfde      		rjmp	mainloop
                 
                 ;------------------------------------------------------------------------------------------
                 ; Read N64 controller
                 ;
                 ; Continually read N64 controller and update GC data
                 ;------------------------------------------------------------------------------------------
                 readn64:
000067 2455      		clr		recal
                 
000068 e020      		ldi		nsix1, 0
000069 e030      		ldi		nsix2, 0
00006a e000      		ldi		temp1, 0
00006b e010      		ldi		temp2, 0
                 
00006c 2400      		clr		gcint			; reset interrupted flag
                 
                 		; send 0x01 to read controller status words
00006d e061      		ldi		param, 0x01
00006e d084      		rcall	writebyte
00006f d0a5      		rcall	writestopbit
                 
000070 9ad8      		sbi		PORTA, 0		; debug
000071 98d8      		cbi		PORTA, 0
                 
                 		; read three bytes for id
000072 d066      		rcall	readbyte		; buttons 1
000073 2f26      		mov		nsix1, param
000074 d064      		rcall	readbyte		; buttons 2
000075 2f36      		mov		nsix2, param
                 
000076 d062      		rcall	readbyte		; stick x
000077 2f06      		mov		temp1, param
000078 d060      		rcall	readbyte		; stick y
000079 2f16      		mov		temp2, param
                 
00007a e060      		ldi		param, 0
00007b 1606      		cp		gcint, param
00007c f009      		breq	dataok
00007d cfc7      		rjmp	mainloop
                 
                 dataok:
                 		;cbi		PORTA, 0		; debug
                 		;sbi		PORTA, 0
                 		;cbi		PORTA, 0
                 		;sbi		PORTA, 0
                 		;cbi		PORTA, 0
                 		;sbi		PORTA, 0
                 		;cbi		PORTA, 0
                 
00007e e76f      		ldi		param, 0x7f
00007f 0f06      		add		temp1, param
000080 0f16      		add		temp2, param
000081 2ec0      		mov		gcx, temp1		; x/y can be transferred directly over
000082 2ed1      		mov		gcy, temp2
                 
000083 e000      		ldi		temp1, 0		; check if calibration data needs setting
000084 1660      		cp		calx, temp1
000085 f189      		breq	setcalibration
                 
000086 e000      		ldi		temp1, 0
000087 e010      		ldi		temp2, 0
                 
                 		; 1:	N64				Gamecube
                 		;		0 - Right		2-1
                 		;		1 - Left		2-0
                 		;		2 - Down		2-2
                 		;		3 - Up			2-3
                 		;		4 - Start		1-4
                 		;		5 - Z (left)	2-5 (L) (originally 2-4)
                 		;		6 - B			1-1
                 		;		7 - A			1-0
                 
000088 fd27      		sbrc	nsix1, 7		; A
000089 6001      		ori		temp1, (1<<0)
00008a fd26      		sbrc	nsix1, 6		; B
00008b 6002      		ori		temp1, (1<<1)
                 
00008c e060      		ldi		param, 0
00008d fd25      		sbrc	nsix1, 5		; Z (left, in returned data)
00008e 6410      		ori		temp2, (1<<6)	; (L)
00008f fd25      		sbrc	nsix1, 5
000090 ef6f      		ldi		param, 0xff
000091 2ee6      		mov		gcl, param
                 		;ser		param
                 		;mov		shift, param
                 	
000092 e060      		ldi		param, 0
000093 9bb1      		sbis	PINB, z2		; Z (right, separated)
000094 6210      		ori		temp2, (1<<5)	; (R)
000095 9bb1      		sbis	PINB, z2
000096 ef6f      		ldi		param, 0xff
000097 2ef6      		mov		gcr, param
                 		;ori		temp2, (1<<4)
                 
000098 fd24      		sbrc	nsix1, 4		; Start
000099 6100      		ori		temp1, (1<<4)
                 
00009a fd23      		sbrc	nsix1, 3		; Up
00009b 6018      		ori		temp2, (1<<3)
00009c fd22      		sbrc	nsix1, 2		; Down
00009d 6014      		ori		temp2, (1<<2)
00009e fd21      		sbrc	nsix1, 1		; Left
00009f 6011      		ori		temp2, (1<<0)
0000a0 fd20      		sbrc	nsix1, 0		; Right
0000a1 6012      		ori		temp2, (1<<1)
                 
                 		; 2:	N64				Gamecube
                 		;		0 - C-Right		1-3 (Y)
                 		;		1 - C-Left		1-2 (X)
                 		;		2 - C-Down		1-3 (Y)
                 		;		3 - C-Up		1-2 (X)
                 		;		4 - L			2-5
                 		;		5 - R			2-6
                 
0000a2 ef6f      		ser		param
0000a3 fd35      		sbrc	nsix2, 5		; L
0000a4 2e46      		mov		shift, param
0000a5 ff35      		sbrs	nsix2, 5		; L
0000a6 2444      		clr		shift
                 		;ori		temp2, (1<<5)
                 
                 		;ldi		param, 0x00
                 		;sbrc	nsix2, 4		; L
                 		;ldi		param, 0xff
                 		;mov		gcl, param
                 
0000a7 fd34      		sbrc	nsix2, 4		; R
0000a8 6110      		ori		temp2, (1<<4)
                 		;ori		temp2, (1<<6)
                 
                 		;ldi		param, 0x00
                 		;sbrc	nsix2, 5		; R
                 		;ldi		param, 0xff
                 		;mov		gcr, param
                 
0000a9 fd32      		sbrc	nsix2, 2		; C-Down
0000aa 6008      		ori		temp1, (1<<3)
0000ab fd30      		sbrc	nsix2, 0		; C-Right
0000ac 6008      		ori		temp1, (1<<3)
0000ad fd33      		sbrc	nsix2, 3		; C-Up
0000ae 6004      		ori		temp1, (1<<2)
0000af fd31      		sbrc	nsix2, 1		; C-Left
0000b0 6004      		ori		temp1, (1<<2)
                 
0000b1 6810      		ori		temp2, (1<<7)	; bit 7 always 1
                 
0000b2 2ea0      		mov		gc1, temp1		; update GC status
0000b3 2eb1      		mov		gc2, temp2
                 
                 		;cp		rwant, rstate	; check if rumble setting needs to be changed
                 		;breq	norchange
0000b4 d12d      		rcall	changerumble
                 norchange:
                 
0000b5 9478      		sei						; start responding to Gamecube if not already
                 
0000b6 cf8e      		rjmp	mainloop
                 
                 ;------------------------------------------------------------------------------------------
                 ; Set calibration data to the first stick readings taken
                 ;------------------------------------------------------------------------------------------
                 setcalibration:
0000b7 2c6c      		mov		calx, gcx
0000b8 2c7d      		mov		caly, gcy
                 
0000b9 9ad9      		sbi		PORTA, 1		; debug
0000ba 0000      		nop
0000bb 9ad8      		sbi		PORTA, 0
0000bc 0000      		nop
0000bd 98d9      		cbi		PORTA, 1
0000be 0000      		nop
0000bf 98d8      		cbi		PORTA, 0
                 
0000c0 d002      		rcall	initrumble
                 
0000c1 9478      		sei						; start responding to the Gamecube
                 
0000c2 cf82      		rjmp	mainloop
                 
                 ;------------------------------------------------------------------------------------------
                 ; Set calibration data to the first stick readings taken
                 ;------------------------------------------------------------------------------------------
                 initrumble:
                +
0000c3 ef5f     +ldi timer , 255
                +DELAY_LOOP :
0000c4 955a     +dec timer
0000c5 f7f1     +brne DELAY_LOOP
                 		DELAY	255
                +
0000c6 e956     +ldi timer , 150
                +DELAY_LOOP :
0000c7 955a     +dec timer
0000c8 f7f1     +brne DELAY_LOOP
                 		DELAY	150
                 
0000c9 e202      		ldi		temp1, 34
                 
0000ca e063      		ldi		param, 0x03
0000cb d027      		rcall	writebyte
0000cc e860      		ldi		param, 0x80
0000cd d025      		rcall	writebyte
0000ce e061      		ldi		param, 0x01
0000cf d023      		rcall	writebyte
                 initrumbleloop:
0000d0 e860      		ldi		param, 0x80
0000d1 d021      		rcall	writebyte
0000d2 950a      		dec		temp1
0000d3 f7e1      		brne	initrumbleloop
                 
0000d4 d040      		rcall	writestopbit
                 
0000d5 d003      		rcall	readbyte
0000d6 d002      		rcall	readbyte
0000d7 d001      		rcall	readbyte
                 
0000d8 9508      		ret
                 
                 ;------------------------------------------------------------------------------------------
                 ; Read byte from N64 controller
                 ;
                 ; Byte in param, timer and count trashed
                 ;------------------------------------------------------------------------------------------
                 readbyte:
0000d9 e060      		ldi		param, 0
0000da e154      		ldi		timer, 20
0000db e048      		ldi		count, 8
                 in_byte:
0000dc 955a      		dec		timer
0000dd f0a1      		breq	timeout
0000de 99b3      		sbic	PINB, nsd
0000df cffc      		rjmp	in_byte
                +
0000e0 e058     +ldi timer , MSD2
                +DELAY_LOOP :
0000e1 955a     +dec timer
0000e2 f7f1     +brne DELAY_LOOP
                 		DELAY	MSD2			;~2us
0000e3 0f66      		lsl		param
0000e4 0000      		nop
0000e5 0000      		nop
                 		;sbi		PORTA, 0		; debug
                 		;cbi		PORTA, 0		; debug
0000e6 99b3      		sbic	PINB, nsd
0000e7 6061      		ori		param, 0b00000001
                 
0000e8 fd60      		sbrc	param, 0
0000e9 9ad8      		sbi		PORTA, 0		; debug
0000ea 98d8      		cbi		PORTA, 0		; debug
                 
0000eb e154      		ldi		timer, 20
                 in_wait_high:
0000ec 955a      		dec		timer
0000ed f021      		breq	timeout
0000ee 9bb3      		sbis	PINB, nsd
0000ef cffc      		rjmp	in_wait_high
0000f0 954a      		dec		count
0000f1 f751      		brne	in_byte
                 
                 timeout:
0000f2 9508      		ret
                 
                 ;------------------------------------------------------------------------------------------
                 ; Write byte to N64 controller
                 ;
                 ; Byte in param, param and count trashed
                 ;------------------------------------------------------------------------------------------
                 writebyte:
0000f3 e048      		ldi		count, 8
                 
                 out_loop:
0000f4 fd67      		sbrc	param, 7
0000f5 c00f      		rjmp	out_1
                 		
                 		; send a 0
0000f6 9abb      		sbi		DDRB, nsd
                +
0000f7 e05e     +ldi timer , MSD3
                +DELAY_LOOP :
0000f8 955a     +dec timer
0000f9 f7f1     +brne DELAY_LOOP
                 		DELAY	MSD3
0000fa 0000      		nop
0000fb 98bb      		cbi		DDRB, nsd
                +
0000fc e052     +ldi timer , MSD1
                +DELAY_LOOP :
0000fd 955a     +dec timer
0000fe f7f1     +brne DELAY_LOOP
                 		DELAY	MSD1
0000ff 0000      		nop
000100 0000      		nop
000101 0f66      		lsl		param
000102 954a      		dec		count
000103 f781      		brne	out_loop
                 
000104 9508      		ret
                 
                 out_1:
                 		; send a 1
000105 9abb      		sbi		DDRB, nsd
                +
000106 e053     +ldi timer , 3
                +DELAY_LOOP :
000107 955a     +dec timer
000108 f7f1     +brne DELAY_LOOP
                 		DELAY	3			; MSD1
000109 0000      		nop
00010a 0000      		nop
00010b 0000      		nop
00010c 98bb      		cbi		DDRB, nsd
                +
00010d e05e     +ldi timer , MSD3
                +DELAY_LOOP :
00010e 955a     +dec timer
00010f f7f1     +brne DELAY_LOOP
                 		DELAY	MSD3
000110 0000      		nop
000111 0f66      		lsl		param
000112 954a      		dec		count
000113 f701      		brne	out_loop
                 
000114 9508      		ret
                 
                 ;------------------------------------------------------------------------------------------
                 ; Write stop bit to N64 controller
                 ;
                 ; timer trashed
                 ;------------------------------------------------------------------------------------------
                 writestopbit:
                 		; send stop bit
000115 9abb      		sbi		DDRB, nsd
                +
000116 e054     +ldi timer , 4
                +DELAY_LOOP :
000117 955a     +dec timer
000118 f7f1     +brne DELAY_LOOP
                 		DELAY	4
000119 0000      		nop
00011a 98bb      		cbi		DDRB, nsd
                 
00011b 9508      		ret
                 
                 ;------------------------------------------------------------------------------------------
                 ; Handle poll from Gamecube
                 ;------------------------------------------------------------------------------------------
                 INT0handler:
                 		;sbic	PINB, gcd		; make sure data pin is low to prevent false starts
                 		;reti
                 
00011c 2400      		clr		gcint
00011d 9403      		inc		gcint
                 
                 		;sbi		PORTA, 1		; debug
                 		;cbi		PORTA, 1
                 		;cbi		PORTA, 0
                 
                 		; Assume first bit is 0. We then have time to save work registers before next bit.
00011e 930f      		push	temp1
00011f 931f      		push	temp2
000120 935f      		push	timer
000121 934f      		push	count
000122 936f      		push	param
                 
000123 e000      		ldi		temp1, 0
                 
                 		; Read 7 bits
000124 e047      		ldi		count, 7
                 gcread:
000125 e154      		ldi		timer, 20
                 gcread_wait_high:
000126 955a      		dec		timer
000127 f0d1      		breq	gctimeout
000128 9bb6      		sbis	PINB, gcd
000129 cffc      		rjmp	gcread_wait_high
                 
00012a e154      		ldi		timer, 20
                 gcread_wait_low:
00012b 955a      		dec		timer
00012c f0a9      		breq	gctimeout
00012d 99b6      		sbic	PINB, gcd
00012e cffc      		rjmp	gcread_wait_low
                 
                +
00012f e058     +ldi timer , MSD2
                +DELAY_LOOP :
000130 955a     +dec timer
000131 f7f1     +brne DELAY_LOOP
                 		DELAY	MSD2			; ~2us
000132 0f00      		lsl		temp1
000133 9ad9      		sbi		PORTA, 1		; debug
000134 98d9      		cbi		PORTA, 1
000135 99b6      		sbic	PINB, gcd
000136 6001      		ori		temp1, 0b00000001
                 
000137 954a      		dec		count
000138 f761      		brne	gcread
                 
                 		; Check for 0x40 command, in which case we need to read two more bytes.
                 		; Otherwise, expect stop bit
                 
000139 3400      		cpi		temp1, 0x40
00013a f1e1      		breq	gcreturn_status
                 
00013b d01b      		rcall	gcreadstopbit	; wait for stop bit
                 
                 		; Check command
                 		; Note - stop bit is still low at this point, need to wait for line to go high
                 		; again.
00013c 3000      		cpi		temp1, 0x00		; get controller ID
00013d f409      		brne	gc_not_id		; due to jump limits on conditional branching
00013e c0f1      		rjmp	gcreturn_id
                 
                 gc_not_id:
00013f 3401      		cpi		temp1, 0x41		; origins
000140 f409      		brne	gc_not_origins	; due to jump limits on conditional branching
000141 c0cd      		rjmp	gcreturn_origins
                 
                 gc_not_origins:
                 		; Unknown command or bad data, exit with timeout failure on debug
                 
                 ;------------------------------------------------------------------------------------------
                 ; Write timeout failure to GC debug
                 ;
                 ; timer trashed
                 ;------------------------------------------------------------------------------------------
                 gctimeout:
                +
000142 e154     +ldi timer , 20
                +DELAY_LOOP :
000143 955a     +dec timer
000144 f7f1     +brne DELAY_LOOP
                 		DELAY	20
000145 9ad9      		sbi		PORTA, 1		; debug
000146 98d9      		cbi		PORTA, 1
000147 9ad9      		sbi		PORTA, 1		; debug
000148 98d9      		cbi		PORTA, 1
000149 9ad9      		sbi		PORTA, 1		; debug
00014a 98d9      		cbi		PORTA, 1
00014b 9ad9      		sbi		PORTA, 1		; debug
00014c 98d9      		cbi		PORTA, 1
00014d 9ad9      		sbi		PORTA, 1		; debug
00014e 98d9      		cbi		PORTA, 1
00014f 9ad9      		sbi		PORTA, 1		; debug
000150 98d9      		cbi		PORTA, 1
                 
                 ;------------------------------------------------------------------------------------------
                 ; Exit from interrupt, restore saved registers
                 ;------------------------------------------------------------------------------------------
                 exitint0:
000151 916f      		pop		param
000152 914f      		pop		count
000153 915f      		pop		timer
000154 911f      		pop		temp2
000155 910f      		pop		temp1
000156 9518      		reti
                 
                 ;------------------------------------------------------------------------------------------
                 ; Wait for stop bit to arrive and finish
                 ;
                 ; timer trashed
                 ;------------------------------------------------------------------------------------------
                 gcreadstopbit:
000157 e352      		ldi		timer, 50
                 gcread_stop_bit_high1:
000158 955a      		dec		timer
000159 f341      		breq	gctimeout
00015a 9bb6      		sbis	PINB, gcd
00015b cffc      		rjmp	gcread_stop_bit_high1
                 
00015c e352      		ldi		timer, 50
                 gcread_stop_bit_low:
00015d 955a      		dec		timer
00015e f319      		breq	gctimeout
00015f 99b6      		sbic	PINB, gcd
000160 cffc      		rjmp	gcread_stop_bit_low
                 
000161 e352      		ldi		timer, 50
                 gcread_stop_bit_high2:
000162 955a      		dec		timer
000163 f2f1      		breq	gctimeout
000164 9bb6      		sbis	PINB, gcd
000165 cffc      		rjmp	gcread_stop_bit_high2
                 
000166 9508      		ret
                 
                 ;------------------------------------------------------------------------------------------
                 ; Write timeout failure to GC debug
                 ;
                 ; Same as gctimeout, placed here so it is in reach of conditional branches in
                 ; gcreturn_status
                 ;
                 ; timer trashed
                 ;------------------------------------------------------------------------------------------
                 gctimeout3:
                +
000167 e154     +ldi timer , 20
                +DELAY_LOOP :
000168 955a     +dec timer
000169 f7f1     +brne DELAY_LOOP
                 		DELAY	20
00016a 9ad9      		sbi		PORTA, 1		; debug
00016b 98d9      		cbi		PORTA, 1
00016c 9ad9      		sbi		PORTA, 1		; debug
00016d 98d9      		cbi		PORTA, 1
00016e 9ad9      		sbi		PORTA, 1		; debug
00016f 98d9      		cbi		PORTA, 1
000170 9ad9      		sbi		PORTA, 1		; debug
000171 98d9      		cbi		PORTA, 1
000172 9ad9      		sbi		PORTA, 1		; debug
000173 98d9      		cbi		PORTA, 1
000174 9ad9      		sbi		PORTA, 1		; debug
000175 98d9      		cbi		PORTA, 1
                 
000176 cfda      		rjmp	exitint0
                 
                 ;------------------------------------------------------------------------------------------
                 ; Return GC controller status
                 ;------------------------------------------------------------------------------------------
                 gcreturn_status:
                 		; Read two more bytes
                 		; Could make a function for this but there is plenty of ROM space so...
000177 e048      		ldi		count, 8
000178 e000      		ldi		temp1, 0
                 gcread1:
000179 e154      		ldi		timer, 20
                 gcread_wait_high1:
00017a 955a      		dec		timer
00017b f231      		breq	gctimeout
00017c 9bb6      		sbis	PINB, gcd
00017d cffc      		rjmp	gcread_wait_high1
                 
00017e e154      		ldi		timer, 20
                 gcread_wait_low1:
00017f 955a      		dec		timer
000180 f209      		breq	gctimeout
000181 99b6      		sbic	PINB, gcd
000182 cffc      		rjmp	gcread_wait_low1
                 
                +
000183 e058     +ldi timer , MSD2
                +DELAY_LOOP :
000184 955a     +dec timer
000185 f7f1     +brne DELAY_LOOP
                 		DELAY	MSD2			; ~2us
000186 0f00      		lsl		temp1
000187 9ad9      		sbi		PORTA, 1		; debug
000188 98d9      		cbi		PORTA, 1
000189 99b6      		sbic	PINB, gcd
00018a 6001      		ori		temp1, 0b00000001
                 
00018b 954a      		dec		count
00018c f761      		brne	gcread1
                 
                 		; Byte 2
00018d e048      		ldi		count, 8
                 gcread2:
00018e e154      		ldi		timer, 20
                 gcread_wait_high2:
00018f 955a      		dec		timer
000190 f2b1      		breq	gctimeout3
000191 9bb6      		sbis	PINB, gcd
000192 cffc      		rjmp	gcread_wait_high2
                 
000193 e154      		ldi		timer, 20
                 gcread_wait_low2:
000194 955a      		dec		timer
000195 f289      		breq	gctimeout3
000196 99b6      		sbic	PINB, gcd
000197 cffc      		rjmp	gcread_wait_low2
                 
                +
000198 e058     +ldi timer , MSD2
                +DELAY_LOOP :
000199 955a     +dec timer
00019a f7f1     +brne DELAY_LOOP
                 		DELAY	MSD2			; ~2us
00019b 0f11      		lsl		temp2
00019c 9ad9      		sbi		PORTA, 1		; debug
00019d 98d9      		cbi		PORTA, 1
00019e 99b6      		sbic	PINB, gcd
00019f 6011      		ori		temp2, 0b00000001
                 
0001a0 954a      		dec		count
0001a1 f761      		brne	gcread2
                 
0001a2 dfb4      		rcall	gcreadstopbit	; wait for stop bit
                 
                 		; Check command
0001a3 3003      		cpi		temp1, 0x03		; only known command, check status
0001a4 f569      		brne	gctimeout2		; otherwise fail
                 
0001a5 2433      		clr		rwant
0001a6 fd10      		sbrc	temp2, 0
0001a7 9433      		inc		rwant
                 
0001a8 2044      		tst		shift
0001a9 f4a1      		brne	gcstatus_shifted
                 
0001aa 2d6a      		mov		param, gc1		; 0 buttons
0001ab d097      		rcall	gcwritebyte
0001ac 2d6b      		mov		param, gc2		; 1 buttons
0001ad d095      		rcall	gcwritebyte
0001ae 2d6c      		mov		param, gcx		; 2 joystick x
0001af d093      		rcall	gcwritebyte
0001b0 2d6d      		mov		param, gcy		; 3 joystick y
0001b1 d091      		rcall	gcwritebyte
0001b2 2d66      		mov		param, calx		; 4 c-stick x
0001b3 d08f      		rcall	gcwritebyte
0001b4 2d67      		mov		param, caly		; 5 c-stick y
0001b5 d08d      		rcall	gcwritebyte
0001b6 2d6e      		mov		param, gcl		; 6 left trigger
0001b7 d08b      		rcall	gcwritebyte
0001b8 2d6f      		mov		param, gcr		; 7 right trigger
0001b9 d089      		rcall	gcwritebyte
                 
0001ba d0ab      		rcall	gcwritestopbit
                 
0001bb 9ad9      		sbi		PORTA, 1		; debug
0001bc 98d9      		cbi		PORTA, 1
                 
0001bd cf93      		rjmp	exitint0
                 
                 gcstatus_shifted:
0001be 2d6a      		mov		param, gc1		; 0 buttons
0001bf d083      		rcall	gcwritebyte
0001c0 2d6b      		mov		param, gc2		; 1 buttons
0001c1 d081      		rcall	gcwritebyte
0001c2 2d66      		mov		param, calx		; 2 joystick x
0001c3 d07f      		rcall	gcwritebyte
0001c4 2d67      		mov		param, caly		; 3 joystick y
0001c5 d07d      		rcall	gcwritebyte
0001c6 2d6c      		mov		param, gcx		; 4 c-stick x
0001c7 d07b      		rcall	gcwritebyte
0001c8 2d6d      		mov		param, gcy		; 5 c-stick y
0001c9 d079      		rcall	gcwritebyte
0001ca 2d6e      		mov		param, gcl		; 6 left trigger
0001cb d077      		rcall	gcwritebyte
0001cc 2d6f      		mov		param, gcr		; 7 right trigger
0001cd d075      		rcall	gcwritebyte
                 
0001ce d097      		rcall	gcwritestopbit
                 
0001cf 9ad9      		sbi		PORTA, 1		; debug
0001d0 98d9      		cbi		PORTA, 1
                 
0001d1 cf7f      		rjmp	exitint0
                 
                 ;------------------------------------------------------------------------------------------
                 ; Write timeout failure to GC debug
                 ;
                 ; Same as gctimeout, placed here so it is in reach of conditional branches in
                 ; gcreturn_status
                 ;
                 ; timer trashed
                 ;------------------------------------------------------------------------------------------
                 gctimeout2:
                +
0001d2 e154     +ldi timer , 20
                +DELAY_LOOP :
0001d3 955a     +dec timer
0001d4 f7f1     +brne DELAY_LOOP
                 		DELAY	20
0001d5 9ad9      		sbi		PORTA, 1		; debug
0001d6 98d9      		cbi		PORTA, 1
0001d7 9ad9      		sbi		PORTA, 1		; debug
0001d8 98d9      		cbi		PORTA, 1
0001d9 9ad9      		sbi		PORTA, 1		; debug
0001da 98d9      		cbi		PORTA, 1
0001db 9ad9      		sbi		PORTA, 1		; debug
0001dc 98d9      		cbi		PORTA, 1
0001dd 9ad9      		sbi		PORTA, 1		; debug
0001de 98d9      		cbi		PORTA, 1
0001df 9ad9      		sbi		PORTA, 1		; debug
0001e0 98d9      		cbi		PORTA, 1
                 
0001e1 cf6f      		rjmp	exitint0
                 
                 ;------------------------------------------------------------------------------------------
                 ; Set calibration data to the first stick readings taken
                 ;------------------------------------------------------------------------------------------
                 changerumble:
                +
0001e2 ef5a     +ldi timer , 250
                +DELAY_LOOP :
0001e3 955a     +dec timer
0001e4 f7f1     +brne DELAY_LOOP
                 		DELAY	250
                +
0001e5 e956     +ldi timer , 150
                +DELAY_LOOP :
0001e6 955a     +dec timer
0001e7 f7f1     +brne DELAY_LOOP
                 		DELAY	150
                 
0001e8 9ada      		sbi		PORTA, 2
0001e9 98da      		cbi		PORTA, 2
                 
0001ea 2033      		tst		rwant
0001eb f489      		brne	rumbleon
                 
                 		; set rumble to off
0001ec 2488      		clr		rstate
0001ed e200      		ldi		temp1, 32
                 
0001ee e063      		ldi		param, 0x03
0001ef df03      		rcall	writebyte
0001f0 ec60      		ldi		param, 0xc0
0001f1 df01      		rcall	writebyte
0001f2 e16b      		ldi		param, 0x1b
0001f3 deff      		rcall	writebyte
                 roffloop:
0001f4 e060      		ldi		param, 0x00
0001f5 defd      		rcall	writebyte
0001f6 950a      		dec		temp1
0001f7 f7e1      		brne	roffloop
                 
0001f8 df1c      		rcall	writestopbit
                 
0001f9 dedf      		rcall	readbyte
0001fa dede      		rcall	readbyte
0001fb dedd      		rcall	readbyte
                 
0001fc 9508      		ret
                 
                 rumbleon:
                 		; set rumble to on
0001fd 2488      		clr		rstate
0001fe 9483      		inc		rstate
0001ff e200      		ldi		temp1, 32
                 
000200 e063      		ldi		param, 0x03
000201 def1      		rcall	writebyte
000202 ec60      		ldi		param, 0xc0
000203 deef      		rcall	writebyte
000204 e16b      		ldi		param, 0x1b
000205 deed      		rcall	writebyte
                 ronloop:
000206 e061      		ldi		param, 0x01
000207 deeb      		rcall	writebyte
000208 950a      		dec		temp1
000209 f7e1      		brne	ronloop
                 
00020a df0a      		rcall	writestopbit
                 
00020b decd      		rcall	readbyte
00020c decc      		rcall	readbyte
00020d decb      		rcall	readbyte
                 
00020e 9508      		ret
                 
                 ;------------------------------------------------------------------------------------------
                 ; Return GC controller origins
                 ;
                 ; Return an ideal result of 00 80 80 80 80 80 00 00 02 02
                 ;							0  1  2  3  4  5  6  7  8  9
                 ;------------------------------------------------------------------------------------------
                 gcreturn_origins:
                +
00020f e051     +ldi timer , 1
                +DELAY_LOOP :
000210 955a     +dec timer
000211 f7f1     +brne DELAY_LOOP
                 		DELAY	1
000212 0000      		nop
000213 0000      		nop
000214 0000      		nop
000215 0000      		nop
                 
000216 9ad9      		sbi		PORTA, 1		; debug
000217 98d9      		cbi		PORTA, 1
                 
000218 e060      		ldi		param, 0x00		; 0	buttons
000219 d029      		rcall	gcwritebyte
00021a e860      		ldi		param, 0x80		; 1 buttons
00021b d027      		rcall	gcwritebyte
00021c 2d66      		mov		param, calx		; 2 joystick x
00021d d025      		rcall	gcwritebyte
00021e 2d67      		mov		param, caly		; 3 joystick y
00021f d023      		rcall	gcwritebyte
000220 2d66      		mov		param, calx		; 4 c-stick x
000221 d021      		rcall	gcwritebyte
000222 2d67      		mov		param, caly		; 5 c-stick y
000223 d01f      		rcall	gcwritebyte
000224 e060      		ldi		param, 0x00		; 6 left trigger
000225 d01d      		rcall	gcwritebyte
000226 e060      		ldi		param, 0x00		; 7 right trigger
000227 d01b      		rcall	gcwritebyte
000228 e062      		ldi		param, 0x02		; 8 dead zone?
000229 d019      		rcall	gcwritebyte
00022a e062      		ldi		param, 0x02		; 9 dead zone?
00022b d017      		rcall	gcwritebyte
                 
00022c d039      		rcall	gcwritestopbit
                 
00022d 9ad9      		sbi		PORTA, 1		; debug
00022e 98d9      		cbi		PORTA, 1
                 
00022f cf21      		rjmp	exitint0		
                 
                 ;------------------------------------------------------------------------------------------
                 ; Return GC controller ID
                 ;------------------------------------------------------------------------------------------
                 gcreturn_id:
                +
000230 e051     +ldi timer , 1
                +DELAY_LOOP :
000231 955a     +dec timer
000232 f7f1     +brne DELAY_LOOP
                 		DELAY	1
000233 0000      		nop
000234 0000      		nop
000235 0000      		nop
000236 0000      		nop
                 
000237 9ad9      		sbi		PORTA, 1		; debug
000238 98d9      		cbi		PORTA, 1
                 
000239 e069      		ldi		param, 0x09
00023a d008      		rcall	gcwritebyte
00023b e060      		ldi		param, 0x00
00023c d006      		rcall	gcwritebyte
00023d e260      		ldi		param, 0x20
00023e d004      		rcall	gcwritebyte
00023f d026      		rcall	gcwritestopbit
                 
000240 9ad9      		sbi		PORTA, 1		; debug
000241 98d9      		cbi		PORTA, 1
                 
000242 cf0e      		rjmp	exitint0		
                 
                 ;------------------------------------------------------------------------------------------
                 ; Write byte to GC controller
                 ;
                 ; Byte in param, param and count trashed
                 ;------------------------------------------------------------------------------------------
                 gcwritebyte:
000243 e048      		ldi		count, 8
                 
                 gc_out_loop:
000244 fd67      		sbrc	param, 7
000245 c00f      		rjmp	gc_out_1
                 		
                 		; send a 0
000246 9abe      		sbi		DDRB, gcd
                +
000247 e05e     +ldi timer , MSD3
                +DELAY_LOOP :
000248 955a     +dec timer
000249 f7f1     +brne DELAY_LOOP
                 		DELAY	MSD3
00024a 0000      		nop
00024b 98be      		cbi		DDRB, gcd
                +
00024c e052     +ldi timer , MSD1
                +DELAY_LOOP :
00024d 955a     +dec timer
00024e f7f1     +brne DELAY_LOOP
                 		DELAY	MSD1
00024f 0000      		nop
000250 0000      		nop
000251 0f66      		lsl		param
000252 954a      		dec		count
000253 f781      		brne	gc_out_loop
                 
000254 9508      		ret
                 
                 gc_out_1:
                 		; send a 1
000255 9abe      		sbi		DDRB, gcd
                +
000256 e052     +ldi timer , MSD1
                +DELAY_LOOP :
000257 955a     +dec timer
000258 f7f1     +brne DELAY_LOOP
                 		DELAY	MSD1
000259 0000      		nop
00025a 0000      		nop
00025b 98be      		cbi		DDRB, gcd
                +
00025c e05e     +ldi timer , MSD3
                +DELAY_LOOP :
00025d 955a     +dec timer
00025e f7f1     +brne DELAY_LOOP
                 		DELAY	MSD3
                 
00025f 9ad8      		sbi		PORTA, 0		; debug
000260 98d8      		cbi		PORTA, 0
                 
000261 0000      		nop
000262 0f66      		lsl		param
000263 954a      		dec		count
000264 f6f9      		brne	gc_out_loop
                 
000265 9508      		ret
                 
                 ;------------------------------------------------------------------------------------------
                 ; Write stop bit to GC controller
                 ;
                 ; timer trashed
                 ;------------------------------------------------------------------------------------------
                 gcwritestopbit:
                 		; send stop bit
                +
000266 e059     +ldi timer , 9
                +DELAY_LOOP :
000267 955a     +dec timer
000268 f7f1     +brne DELAY_LOOP
                 		DELAY	9
000269 9abe      		sbi		DDRB, gcd
                +
00026a e052     +ldi timer , MSD1
                +DELAY_LOOP :
00026b 955a     +dec timer
00026c f7f1     +brne DELAY_LOOP
                 		DELAY	MSD1
00026d 98be      		cbi		DDRB, gcd
                 
00026e 9508      		ret


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATtiny461 register use summary:
r0 :   4 r1 :   0 r2 :   0 r3 :   4 r4 :   4 r5 :   2 r6 :   8 r7 :   7 
r8 :   4 r9 :   0 r10:   4 r11:   4 r12:   5 r13:   5 r14:   4 r15:   4 
r16:  45 r17:  20 r18:  14 r19:  11 r20:  16 r21:  80 r22:  75 r23:   0 
r24:   0 r25:   0 r26:   0 r27:   0 r28:   0 r29:   0 r30:   0 r31:   0 
x  :   0 y  :   0 z  :   0 
Registers used: 20 out of 35 (57.1%)

ATtiny461 instruction use summary:
adc   :   0 add   :   2 adiw  :   0 and   :   0 andi  :   0 asr   :   0 
bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :   0 brcs  :   0 
break :   0 breq  :  15 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 brne  :  45 brpl  :   0 
brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   0 cbi   :  65 cbr   :   0 clc   :   0 clh   :   0 cli   :   1 
cln   :   0 clr   :  20 cls   :   0 clt   :   0 clv   :   0 clz   :   0 
com   :   0 cp    :   3 cpc   :   0 cpi   :   5 cpse  :   0 dec   :  50 
eor   :   0 icall :   0 ijmp  :   0 in    :   0 inc   :   3 ld    :   0 
ldd   :   0 ldi   :  96 lds   :   0 lpm   :   0 lsl   :   8 lsr   :   0 
mov   :  36 movw  :   0 neg   :   0 nop   :  27 or    :   0 ori   :  19 
out   :   4 pop   :   5 push  :   5 rcall :  72 ret   :  11 reti  :   1 
rjmp  :  27 rol   :   0 ror   :   0 sbc   :   0 sbci  :   0 sbi   :  61 
sbic  :   9 sbis  :   8 sbiw  :   0 sbr   :   0 sbrc  :  19 sbrs  :   1 
sec   :   0 seh   :   0 sei   :   2 sen   :   0 ser   :   1 ses   :   0 
set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 
std   :   0 sts   :   0 sub   :   0 subi  :   0 swap  :   0 tst   :   2 
wdr   :   0 
Instructions used: 30 out of 103 (29.1%)

ATtiny461 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0004de   1246      0   1246    4096  30.4%
[.dseg] 0x000060 0x000060      0      0      0     256   0.0%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 0 warnings
